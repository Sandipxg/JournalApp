# ðŸ›¡ï¸ Spring Security + MongoDB (Full Video Summary)

ðŸ”‘ Core Concepts of Spring Security (Authentication vs Authorization)
ðŸ§© SecurityFilterChain step-by-step with explanations for each method
ðŸ”„ BCrypt Password Encoding and why itâ€™s used
ðŸ—„ï¸ UserDetailsService Implementation and its role
ðŸŒ Basic Auth explained with examples for Postman
ðŸ§  SecurityContextHolder & Authentication Object usage and what data it holds
ðŸ”§ CSRF Disable Reasoning (REST API best practice vs Web app risk)
ðŸ“ Practical Tips (creating users, testing endpoints, resolving 401s)
âš ï¸ Common Issues & Fixes (IP whitelisting in MongoDB, allow-circular-references, etc.)

============================================================
ðŸ“– CHAPTER 1 â€“ AUTHENTICATION VS AUTHORIZATION
============================================================

**Authentication** â†’ Confirms **who you are**
--> Checks username & password
--> Example: Logging in with your credentials

**Authorization** â†’ Confirms **what you can do**
--> Checks roles & permissions
--> Example: Only ADMIN can access /admin/**

ðŸ”‘ Both are required for a secure system:
--> Without authentication â†’ anyone can access anything
--> Without authorization â†’ all users can access admin features


============================================================
ðŸ“– CHAPTER 2 â€“ ADDING SPRING SECURITY DEPENDENCY
============================================================

Add to pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

Once added:
--> All endpoints are secured by default
--> Spring Boot generates a random password on startup (printed in console)
--> Basic login form is automatically provided


============================================================
ðŸ“– CHAPTER 3 â€“ DEFAULT SPRING SECURITY BEHAVIOR
============================================================

--> By default, every endpoint requires authentication
--> Default username: user
--> Password: printed in console logs at startup

Example log:
Using generated security password: a1b2c3d4-xxxx-xxxx

This is only good for quick testing.
We need custom users + MongoDB â†’ handled in later chapters.


============================================================
ðŸ“– CHAPTER 4 â€“ CUSTOM SECURITY CONFIGURATION
============================================================

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.authorizeHttpRequests(request -> request
                    .requestMatchers("/public/**").permitAll()
                    .requestMatchers("/journal/**", "/user/**").authenticated()
                    .requestMatchers("/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated())
            .httpBasic(Customizer.withDefaults())
            .csrf(AbstractHttpConfigurer::disable)
            .build();
}

Explanation:
--> /public/** â†’ anyone can access
--> authenticated() â†’ login required
--> hasRole("ADMIN") â†’ only admin users can access
--> anyRequest().authenticated() â†’ catch-all rule
--> httpBasic() â†’ enables HTTP Basic Auth (simple username/password)
--> csrf().disable() â†’ disable CSRF for REST APIs


============================================================
ðŸ“– CHAPTER 5 â€“ CONNECTING TO MONGODB
============================================================

application.properties:

spring.data.mongodb.uri=mongodb+srv://<username>:<password>@<cluster-url>/<database>?retryWrites=true&w=majority&authSource=admin

--> Users stored & retrieved from MongoDB
--> Requires spring-boot-starter-data-mongodb dependency


============================================================
ðŸ“– CHAPTER 6 â€“ CREATING USER ENTITY & REPOSITORY
============================================================

User.java:
@Data
@Document
public class User {
    private String id;
    private String username;
    private String password;
    private List<String> roles;
}

UserRepository.java:
public interface UserRepository extends MongoRepository<User, String> {
    Optional<User> findByUsername(String username);
}


============================================================
ðŸ“– CHAPTER 7 â€“ PASSWORD ENCODING WITH BCRYPT
============================================================

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

--> Prevents storing plaintext passwords
--> Spring Security automatically verifies hashed password during login


============================================================
ðŸ“– CHAPTER 8 â€“ CUSTOM USERDETAILSSERVICE
============================================================


@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                     .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getRoles().stream()
                    .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                    .collect(Collectors.toList())
        );
    }
}

--> Integrates Spring Security with MongoDB user data


============================================================
ðŸ“– CHAPTER 9 â€“ ROLE-BASED ACCESS CONTROL
============================================================

--> Users have roles: [USER], [ADMIN]
--> Spring Security expects ROLE_ prefix internally
--> hasRole("ADMIN") checks for ROLE_ADMIN

.requestMatchers("/admin/**").hasRole("ADMIN")


============================================================
ðŸ“– CHAPTER 10 â€“ GLOBAL EXCEPTION HANDLING
============================================================

@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleResourceNotFound(ResourceNotFoundException ex, HttpServletRequest request) {
        Map<String, Object> error = new LinkedHashMap<>();
        error.put("timestamp", LocalDateTime.now());
        error.put("status", HttpStatus.NOT_FOUND.value());
        error.put("error", "Not Found");
        error.put("message", ex.getMessage());
        error.put("path", request.getRequestURI());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
}

--> Consistent JSON error responses
--> No raw stack traces exposed
--> Easier debugging for frontend


============================================================
ðŸ“– CHAPTER 11 â€“ TESTING WITH POSTMAN
============================================================

--> Public endpoints â†’ no auth needed
--> Authenticated endpoints â†’ send Basic Auth header
--> Admin endpoints â†’ use account with ROLE_ADMIN

Steps:
1. Create user with POST /public/users
2. Login using Basic Auth with username:password
3. Access /journal/** (authenticated)
4. Access /admin/** (only admin role can access)
