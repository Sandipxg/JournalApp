------------------------------------------------------------------
----------------------- Http Request Filter ----------------------
------------------------------------------------------------------

return http.authorizeHttpRequests(request -> request
    .requestMatchers("/public/**").permitAll()
    .requestMatchers("/journal/**", "/user/**").authenticated()
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .anyRequest().authenticated())


    1] .authorizeHttpRequests()
        This enables authorization rules for HTTP requests.

    2] .requestMatchers("/public/**").permitAll()
        Matches all URLs starting with /public/
        permitAll() → No login needed, anyone can access.
        Example: /public/home, /public/about are freely accessible.

    3] authenticated() → User must be logged in (any valid user can access).
        Example: /journal/add, /user/profile

    4] .requestMatchers("/admin/**").hasRole("ADMIN")
        Matches all URLs starting with /admin/
        Only users with ROLE_ADMIN can access.
        Example: /admin/dashboard

    5] .anyRequest().authenticated()
        Any other URL not listed above must also require login.
        This is a catch-all rule.

    6] .httpBasic(Customizer.withDefaults())
        Enables HTTP Basic Authentication (username/password pop-up or Authorization header in API clients like Postman).
        This is simple but not the most secure option for production. (JWT or OAuth2 is usually better.)

    7] .csrf(AbstractHttpConfigurer::disable)
        CSRF = Cross-Site Request Forgery protection.
        Here, you are disabling it.
        This is common when building REST APIs (because APIs are usually stateless).
        But if you have a web form with sessions (like a normal website), disabling CSRF might make it vulnerable to attacks.

    8] .build();
        Finally, the SecurityFilterChain is built and returned.
        Spring Boot will use this configuration for every incoming request.


------------------------------------------------------------------
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
------------------------------------------------------------------

SecurityContextHolder
    This is a Spring Security class that holds security information (like who is logged in) for the current thread (request).
    Think of it as a “context” for the current request’s authentication.

.getContext()
    Returns the SecurityContext, which contains the authentication object.

.getAuthentication()
    Returns the Authentication object for the current user.
    If the user is not logged in, this can be null or have isAuthenticated() = false.
    If the user is logged in, it contains info like:

getName() → username
    getAuthorities() → roles/permissions
    getCredentials() → usually password (or token, depending on auth)

------------------------------------------------------------------



------------------------------------------------------------------
--------------- UserDetailsService & PasswordEncoder -------------
------------------------------------------------------------------

public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

1] UserDetailsService
    Spring Security interface used to load user-specific data during authentication.
    Custom implementation (UserDetailsServiceImpl) retrieves user details from the database (MongoDB in this case).
    Method loadUserByUsername(String username) returns a UserDetails object containing username, password, and roles.
    Integrates your application’s User entity with Spring Security authentication flow.

2] PasswordEncoder
    BCryptPasswordEncoder hashes passwords before storing them in the database.
    Ensures passwords are not stored in plaintext.
    During login, Spring Security compares hashed passwords automatically.



------------------------------------------------------------------
------------------ Custom Security Configuration -----------------
------------------------------------------------------------------

1] SecurityFilterChain
    Spring Security 6 no longer requires extending WebSecurityConfigurerAdapter.
    Define SecurityFilterChain bean to configure authorization rules.

2] Endpoint segregation
    /public/** → public endpoints, no login needed.
    /journal/** and /user/** → authenticated endpoints.
    /admin/** → accessible only by users with ROLE_ADMIN.
    .anyRequest().authenticated() → any unspecified endpoint also requires login.

3] HTTP Basic Authentication
    Simple authentication mechanism using username/password.
    Credentials sent in Authorization header (Base64 encoded).
    Suitable for testing APIs (like Postman), not recommended for production.

4] CSRF
    Disabled for REST APIs (stateless) using:
    .csrf(AbstractHttpConfigurer::disable)
    Avoids issues with stateful sessions in APIs.



------------------------------------------------------------------

----------------------- User Creation & Roles ----------------------

------------------------------------------------------------------

1] User Entity
    Contains fields like username, password, and roles.
    Passwords should always be stored hashed (BCrypt).

2] UserRepository
    Spring Data MongoDB repository for CRUD operations on users.

3] User Creation Endpoint
    Publicly accessible endpoint to allow new user registration.
    @PostMapping("/users")
    public void createUser(@RequestBody User user){
        userService.saveEntry(user);
    }

4] Role-Based Authorization
    Role list in user entity enables fine-grained access control.
    Example: only ADMIN can access /admin/**.


