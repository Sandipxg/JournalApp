# 🛡️ Spring Security + MongoDB (Full Video Summary)

🔑 Core Concepts of Spring Security (Authentication vs Authorization)
🧩 SecurityFilterChain step-by-step with explanations for each method
🔄 BCrypt Password Encoding and why it’s used
🗄️ UserDetailsService Implementation and its role
🌐 Basic Auth explained with examples for Postman
🧠 SecurityContextHolder & Authentication Object usage and what data it holds
🔧 CSRF Disable Reasoning (REST API best practice vs Web app risk)
📝 Practical Tips (creating users, testing endpoints, resolving 401s)
⚠️ Common Issues & Fixes (IP whitelisting in MongoDB, allow-circular-references, etc.)

============================================================
📖 CHAPTER 1 – AUTHENTICATION VS AUTHORIZATION
============================================================

**Authentication** → Confirms **who you are**
--> Checks username & password
--> Example: Logging in with your credentials

**Authorization** → Confirms **what you can do**
--> Checks roles & permissions
--> Example: Only ADMIN can access /admin/**

🔑 Both are required for a secure system:
--> Without authentication → anyone can access anything
--> Without authorization → all users can access admin features


============================================================
📖 CHAPTER 2 – ADDING SPRING SECURITY DEPENDENCY
============================================================

Add to pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

Once added:
--> All endpoints are secured by default
--> Spring Boot generates a random password on startup (printed in console)
--> Basic login form is automatically provided


============================================================
📖 CHAPTER 3 – DEFAULT SPRING SECURITY BEHAVIOR
============================================================

--> By default, every endpoint requires authentication
--> Default username: user
--> Password: printed in console logs at startup

Example log:
Using generated security password: a1b2c3d4-xxxx-xxxx

This is only good for quick testing.
We need custom users + MongoDB → handled in later chapters.


============================================================
📖 CHAPTER 4 – CUSTOM SECURITY CONFIGURATION
============================================================

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.authorizeHttpRequests(request -> request
                    .requestMatchers("/public/**").permitAll()
                    .requestMatchers("/journal/**", "/user/**").authenticated()
                    .requestMatchers("/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated())
            .httpBasic(Customizer.withDefaults())
            .csrf(AbstractHttpConfigurer::disable)
            .build();
}

Explanation:
--> /public/** → anyone can access
--> authenticated() → login required
--> hasRole("ADMIN") → only admin users can access
--> anyRequest().authenticated() → catch-all rule
--> httpBasic() → enables HTTP Basic Auth (simple username/password)
--> csrf().disable() → disable CSRF for REST APIs


============================================================
📖 CHAPTER 5 – CONNECTING TO MONGODB
============================================================

application.properties:

spring.data.mongodb.uri=mongodb+srv://<username>:<password>@<cluster-url>/<database>?retryWrites=true&w=majority&authSource=admin

--> Users stored & retrieved from MongoDB
--> Requires spring-boot-starter-data-mongodb dependency


============================================================
📖 CHAPTER 6 – CREATING USER ENTITY & REPOSITORY
============================================================

User.java:
@Data
@Document
public class User {
    private String id;
    private String username;
    private String password;
    private List<String> roles;
}

UserRepository.java:
public interface UserRepository extends MongoRepository<User, String> {
    Optional<User> findByUsername(String username);
}


============================================================
📖 CHAPTER 7 – PASSWORD ENCODING WITH BCRYPT
============================================================

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

--> Prevents storing plaintext passwords
--> Spring Security automatically verifies hashed password during login


============================================================
📖 CHAPTER 8 – CUSTOM USERDETAILSSERVICE
============================================================


@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                     .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getRoles().stream()
                    .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                    .collect(Collectors.toList())
        );
    }
}

--> Integrates Spring Security with MongoDB user data


============================================================
📖 CHAPTER 9 – ROLE-BASED ACCESS CONTROL
============================================================

--> Users have roles: [USER], [ADMIN]
--> Spring Security expects ROLE_ prefix internally
--> hasRole("ADMIN") checks for ROLE_ADMIN

.requestMatchers("/admin/**").hasRole("ADMIN")


============================================================
📖 CHAPTER 10 – GLOBAL EXCEPTION HANDLING
============================================================

@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleResourceNotFound(ResourceNotFoundException ex, HttpServletRequest request) {
        Map<String, Object> error = new LinkedHashMap<>();
        error.put("timestamp", LocalDateTime.now());
        error.put("status", HttpStatus.NOT_FOUND.value());
        error.put("error", "Not Found");
        error.put("message", ex.getMessage());
        error.put("path", request.getRequestURI());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
}

--> Consistent JSON error responses
--> No raw stack traces exposed
--> Easier debugging for frontend


============================================================
📖 CHAPTER 11 – TESTING WITH POSTMAN
============================================================

--> Public endpoints → no auth needed
--> Authenticated endpoints → send Basic Auth header
--> Admin endpoints → use account with ROLE_ADMIN

Steps:
1. Create user with POST /public/users
2. Login using Basic Auth with username:password
3. Access /journal/** (authenticated)
4. Access /admin/** (only admin role can access)
